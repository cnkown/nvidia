<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!--
 * Copyright (c) 2009-2014 NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
-->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Jetson Linux Multimedia API Reference: NvV4l2ElementPlane Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="Nvidia.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="reverb-search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="nv.css" rel="stylesheet" type="text/css" />
<style>
 body {
 background-position: 350px 150px;
 background-image: url(watermark.png);
 background-repeat: no-repeat;
 background-attachment: fixed;
 }
</style>
<script type="text/javascript" charset="utf-8" src="https://assets.adobedtm.com/b92787824f2e0e9b68dc2e993f9bd995339fe417/satelliteLib-7ba51e58dc61bcb0e9311aadd02a0108ab24cc6c.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table width="99%" border="0" cellspacing="1" cellpadding="1">
  <tbody>
    <tr valign="middle">
      <td rowspan="2" height="44" width="19%">
        <img src="./NVLogo_2D_H.jpg" width="204" height="44"></td>
      <td width="81%" height="44">
        <h2 style="text-align:right">Jetson Linux Multimedia API Reference</h2>
        <h4 style="text-align:right">
        32.4.3 Release</h4>
    </td>
  </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Welcome</span></a></li>
      <li><a href="grp_terms.html"><span>Important&#160;Terms</span></a></li>
      <li><a href="modules.html"><span>API&#160;Modules</span></a></li>
      <li><a href="l4t_mm_test_group.html"><span>Sample&#160;Applications</span></a></li>
      <li><a href="mmapi_tools.html"><span>Tools</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="usergroup0.html"><span>More</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classNvV4l2ElementPlane.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">NvV4l2ElementPlane Class Reference<div class="ingroups"><a class="el" href="group__l4t__mm__nvv4lelementplane__group.html">NvV4l2ElementPlane Class</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a helper class for operations performed on a V4L2 Element plane. </p>
<p>This derived class is modeled on the planes of a V4L2 Element. It provides convenient wrapper methods around V4L2 IOCTLs associated with plane operations such as <code>VIDIOC_G_FMT/VIDIOC_S_FMT</code>, <code>VIDIOC_REQBUFS</code>, <code>VIDIOC_STREAMON/VIDIOC_STREAMOFF</code>, etc.</p>
<p>The plane buffer type can be either <code>V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code> (for the output plane) or <code>V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code> (for the capture plane).</p>
<p>The plane has an array of <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> object pointers that is allocated and initialized during reqbuf call. These <code><a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a></code> objects are similar to the <code>v4l2_buffer</code> structures that are queued/dequeued.</p>
<p>This class provides another feature useful for multi-threading. On calling <a class="el" href="classNvV4l2ElementPlane.html#a31f77f5e5ed1f320caa44a868a7cbedd" title="Starts DQ Thread. ">startDQThread</a>, it internally spawns a thread that runs infinitely until signaled to stop. This thread keeps trying to dequeue a buffer from the plane and calls a <a class="el" href="classNvV4l2ElementPlane.html#a1f7c50ec5d7c90fd235566556f5bcf97" title="This is a callback function type method that is called by the DQ Thread when it successfully dequeues...">dqThreadCallback</a> method specified by the user on successful dequeue. </p>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00104">104</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f7c50ec5d7c90fd235566556f5bcf97"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a1f7c50ec5d7c90fd235566556f5bcf97">dqThreadCallback</a> )(struct v4l2_buffer *v4l2_buf, <a class="el" href="classNvBuffer.html">NvBuffer</a> *buffer, <a class="el" href="classNvBuffer.html">NvBuffer</a> *shared_buffer, void *data)</td></tr>
<tr class="memdesc:a1f7c50ec5d7c90fd235566556f5bcf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a callback function type method that is called by the DQ Thread when it successfully dequeues a buffer from the plane.  <a href="#a1f7c50ec5d7c90fd235566556f5bcf97">More...</a><br /></td></tr>
<tr class="separator:a1f7c50ec5d7c90fd235566556f5bcf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92938f266cb5c2dd9a9de68af240c835"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a92938f266cb5c2dd9a9de68af240c835">getFormat</a> (struct v4l2_format &amp;format)</td></tr>
<tr class="memdesc:a92938f266cb5c2dd9a9de68af240c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the plane format.  <a href="#a92938f266cb5c2dd9a9de68af240c835">More...</a><br /></td></tr>
<tr class="separator:a92938f266cb5c2dd9a9de68af240c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec63b4567369162dd28b8160401ade30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#aec63b4567369162dd28b8160401ade30">setFormat</a> (struct v4l2_format &amp;format)</td></tr>
<tr class="memdesc:aec63b4567369162dd28b8160401ade30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the plane format.  <a href="#aec63b4567369162dd28b8160401ade30">More...</a><br /></td></tr>
<tr class="separator:aec63b4567369162dd28b8160401ade30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712f71901a43d1e47881bdc7d22a708b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a712f71901a43d1e47881bdc7d22a708b">mapOutputBuffers</a> (struct v4l2_buffer &amp;v4l2_buf, int dmabuff_fd)</td></tr>
<tr class="memdesc:a712f71901a43d1e47881bdc7d22a708b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the NvMMBuffer to <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> for V4L2_MEMORY_DMABUF.  <a href="#a712f71901a43d1e47881bdc7d22a708b">More...</a><br /></td></tr>
<tr class="separator:a712f71901a43d1e47881bdc7d22a708b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed393217479ba28832083efc2a67e733"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#aed393217479ba28832083efc2a67e733">unmapOutputBuffers</a> (int index, int dmabuff_fd)</td></tr>
<tr class="memdesc:aed393217479ba28832083efc2a67e733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the NvMMBuffer for V4L2_MEMORY_DMABUF.  <a href="#aed393217479ba28832083efc2a67e733">More...</a><br /></td></tr>
<tr class="separator:aed393217479ba28832083efc2a67e733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90873cb46d5b5f7cb944e3c2dee0ad40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a90873cb46d5b5f7cb944e3c2dee0ad40">getCrop</a> (struct v4l2_crop &amp;crop)</td></tr>
<tr class="memdesc:a90873cb46d5b5f7cb944e3c2dee0ad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cropping rectangle for the plane.  <a href="#a90873cb46d5b5f7cb944e3c2dee0ad40">More...</a><br /></td></tr>
<tr class="separator:a90873cb46d5b5f7cb944e3c2dee0ad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01797837e4ba47f4737b5846becb182b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a01797837e4ba47f4737b5846becb182b">setSelection</a> (uint32_t target, uint32_t flags, struct v4l2_rect &amp;rect)</td></tr>
<tr class="memdesc:a01797837e4ba47f4737b5846becb182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the selection rectangle for the plane.  <a href="#a01797837e4ba47f4737b5846becb182b">More...</a><br /></td></tr>
<tr class="separator:a01797837e4ba47f4737b5846becb182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88154394fcedad772985741d3d2bfbb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a88154394fcedad772985741d3d2bfbb2">reqbufs</a> (enum v4l2_memory mem_type, uint32_t num)</td></tr>
<tr class="memdesc:a88154394fcedad772985741d3d2bfbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests for buffers on the plane.  <a href="#a88154394fcedad772985741d3d2bfbb2">More...</a><br /></td></tr>
<tr class="separator:a88154394fcedad772985741d3d2bfbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8bfdcbf298d7671e5d7bf73dbb219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a17d8bfdcbf298d7671e5d7bf73dbb219">queryBuffer</a> (uint32_t buf_index)</td></tr>
<tr class="memdesc:a17d8bfdcbf298d7671e5d7bf73dbb219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the status of the buffer at the index.  <a href="#a17d8bfdcbf298d7671e5d7bf73dbb219">More...</a><br /></td></tr>
<tr class="separator:a17d8bfdcbf298d7671e5d7bf73dbb219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81120b7a996c523956227c221f2214df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a81120b7a996c523956227c221f2214df">exportBuffer</a> (uint32_t buf_index)</td></tr>
<tr class="memdesc:a81120b7a996c523956227c221f2214df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the buffer as DMABUF FD.  <a href="#a81120b7a996c523956227c221f2214df">More...</a><br /></td></tr>
<tr class="separator:a81120b7a996c523956227c221f2214df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03164dde4d7ab41f3e92b41e13059316"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a03164dde4d7ab41f3e92b41e13059316">setStreamStatus</a> (bool status)</td></tr>
<tr class="memdesc:a03164dde4d7ab41f3e92b41e13059316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts or stops streaming on the plane.  <a href="#a03164dde4d7ab41f3e92b41e13059316">More...</a><br /></td></tr>
<tr class="separator:a03164dde4d7ab41f3e92b41e13059316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6e57acbf072d72cc425a33ad3b3b7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#aac6e57acbf072d72cc425a33ad3b3b7a">getStreamStatus</a> ()</td></tr>
<tr class="memdesc:aac6e57acbf072d72cc425a33ad3b3b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the plane is streaming.  <a href="#aac6e57acbf072d72cc425a33ad3b3b7a">More...</a><br /></td></tr>
<tr class="separator:aac6e57acbf072d72cc425a33ad3b3b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec8bb8904bb33d995814f02045029c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a5eec8bb8904bb33d995814f02045029c">setStreamParms</a> (struct v4l2_streamparm &amp;parm)</td></tr>
<tr class="memdesc:a5eec8bb8904bb33d995814f02045029c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets streaming parameters.  <a href="#a5eec8bb8904bb33d995814f02045029c">More...</a><br /></td></tr>
<tr class="separator:a5eec8bb8904bb33d995814f02045029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89959f455e5222f686187cc826b1b345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a89959f455e5222f686187cc826b1b345">setupPlane</a> (enum v4l2_memory mem_type, uint32_t num_buffers, bool map, bool allocate)</td></tr>
<tr class="memdesc:a89959f455e5222f686187cc826b1b345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that encapsulates all the method calls required to set up the plane for streaming.  <a href="#a89959f455e5222f686187cc826b1b345">More...</a><br /></td></tr>
<tr class="separator:a89959f455e5222f686187cc826b1b345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89cfe87d8f818beb0478bcf5b72574c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#af89cfe87d8f818beb0478bcf5b72574c">deinitPlane</a> ()</td></tr>
<tr class="memdesc:af89cfe87d8f818beb0478bcf5b72574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that encapsulates all the method calls required to deinitialize the plane for streaming.  <a href="#af89cfe87d8f818beb0478bcf5b72574c">More...</a><br /></td></tr>
<tr class="separator:af89cfe87d8f818beb0478bcf5b72574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb80de93e057abb40702668913b7ac0"><td class="memItemLeft" align="right" valign="top">enum v4l2_buf_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#afcb80de93e057abb40702668913b7ac0">getBufType</a> ()</td></tr>
<tr class="memdesc:afcb80de93e057abb40702668913b7ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the streaming/buffer type of this plane.  <a href="#afcb80de93e057abb40702668913b7ac0">More...</a><br /></td></tr>
<tr class="separator:afcb80de93e057abb40702668913b7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868d438908f3d267dd4af1033133892f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNvBuffer.html">NvBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a868d438908f3d267dd4af1033133892f">getNthBuffer</a> (uint32_t n)</td></tr>
<tr class="memdesc:a868d438908f3d267dd4af1033133892f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a></code> object at index n.  <a href="#a868d438908f3d267dd4af1033133892f">More...</a><br /></td></tr>
<tr class="separator:a868d438908f3d267dd4af1033133892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f34a09328c4dadbd1b20efa9cf4c53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#ad3f34a09328c4dadbd1b20efa9cf4c53">dqBuffer</a> (struct v4l2_buffer &amp;v4l2_buf, <a class="el" href="classNvBuffer.html">NvBuffer</a> **buffer, <a class="el" href="classNvBuffer.html">NvBuffer</a> **shared_buffer, uint32_t num_retries)</td></tr>
<tr class="memdesc:ad3f34a09328c4dadbd1b20efa9cf4c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a buffer from the plane.  <a href="#ad3f34a09328c4dadbd1b20efa9cf4c53">More...</a><br /></td></tr>
<tr class="separator:ad3f34a09328c4dadbd1b20efa9cf4c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bc2789a1af8358759c0f7f205da5ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a70bc2789a1af8358759c0f7f205da5ce">qBuffer</a> (struct v4l2_buffer &amp;v4l2_buf, <a class="el" href="classNvBuffer.html">NvBuffer</a> *shared_buffer)</td></tr>
<tr class="memdesc:a70bc2789a1af8358759c0f7f205da5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a buffer on the plane.  <a href="#a70bc2789a1af8358759c0f7f205da5ce">More...</a><br /></td></tr>
<tr class="separator:a70bc2789a1af8358759c0f7f205da5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cd394a7e0a4afd69395759aeac8787"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#ac5cd394a7e0a4afd69395759aeac8787">getNumBuffers</a> ()</td></tr>
<tr class="memdesc:ac5cd394a7e0a4afd69395759aeac8787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buffers allocated/requested on the plane.  <a href="#ac5cd394a7e0a4afd69395759aeac8787">More...</a><br /></td></tr>
<tr class="separator:ac5cd394a7e0a4afd69395759aeac8787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34236cdee2e7c3e34dda0f227584832"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#ac34236cdee2e7c3e34dda0f227584832">getNumPlanes</a> ()</td></tr>
<tr class="memdesc:ac34236cdee2e7c3e34dda0f227584832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of planes buffers on this plane for the currently set format.  <a href="#ac34236cdee2e7c3e34dda0f227584832">More...</a><br /></td></tr>
<tr class="separator:ac34236cdee2e7c3e34dda0f227584832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf49ef49e3f33de468ba210dd66caa4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#adf49ef49e3f33de468ba210dd66caa4e">setBufferPlaneFormat</a> (int n_planes, <a class="el" href="structNvBuffer_1_1NvBufferPlaneFormat.html">NvBuffer::NvBufferPlaneFormat</a> *planefmts)</td></tr>
<tr class="memdesc:adf49ef49e3f33de468ba210dd66caa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format of the planes of the buffer that is used with this plane.  <a href="#adf49ef49e3f33de468ba210dd66caa4e">More...</a><br /></td></tr>
<tr class="separator:adf49ef49e3f33de468ba210dd66caa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe813f1ac780689ea75207866fe12478"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#abe813f1ac780689ea75207866fe12478">getNumQueuedBuffers</a> ()</td></tr>
<tr class="memdesc:abe813f1ac780689ea75207866fe12478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buffers currently queued on the plane.  <a href="#abe813f1ac780689ea75207866fe12478">More...</a><br /></td></tr>
<tr class="separator:abe813f1ac780689ea75207866fe12478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f17aad888988e08be0a6beb7eadc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a476f17aad888988e08be0a6beb7eadc3">getTotalDequeuedBuffers</a> ()</td></tr>
<tr class="memdesc:a476f17aad888988e08be0a6beb7eadc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of buffers dequeued from the plane.  <a href="#a476f17aad888988e08be0a6beb7eadc3">More...</a><br /></td></tr>
<tr class="separator:a476f17aad888988e08be0a6beb7eadc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f89b524a97ebf05fb93a72f4e027118"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a2f89b524a97ebf05fb93a72f4e027118">getTotalQueuedBuffers</a> ()</td></tr>
<tr class="memdesc:a2f89b524a97ebf05fb93a72f4e027118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of buffers queued on the plane.  <a href="#a2f89b524a97ebf05fb93a72f4e027118">More...</a><br /></td></tr>
<tr class="separator:a2f89b524a97ebf05fb93a72f4e027118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2222d5ca151087f02ea7d26a8bbfb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a0c2222d5ca151087f02ea7d26a8bbfb5">waitAllBuffersQueued</a> (uint32_t max_wait_ms)</td></tr>
<tr class="memdesc:a0c2222d5ca151087f02ea7d26a8bbfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all buffers of the plane are queued.  <a href="#a0c2222d5ca151087f02ea7d26a8bbfb5">More...</a><br /></td></tr>
<tr class="separator:a0c2222d5ca151087f02ea7d26a8bbfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48042ca22a79d45600714ab75671f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#aac48042ca22a79d45600714ab75671f9">waitAllBuffersDequeued</a> (uint32_t max_wait_ms)</td></tr>
<tr class="memdesc:aac48042ca22a79d45600714ab75671f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all buffers of the plane are dequeued.  <a href="#aac48042ca22a79d45600714ab75671f9">More...</a><br /></td></tr>
<tr class="separator:aac48042ca22a79d45600714ab75671f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f213325e0e4857180f5b2319317d6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a37f213325e0e4857180f5b2319317d6a">setDQThreadCallback</a> (<a class="el" href="classNvV4l2ElementPlane.html#a1f7c50ec5d7c90fd235566556f5bcf97">dqThreadCallback</a> callback)</td></tr>
<tr class="memdesc:a37f213325e0e4857180f5b2319317d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the DQ Thread callback method.  <a href="#a37f213325e0e4857180f5b2319317d6a">More...</a><br /></td></tr>
<tr class="separator:a37f213325e0e4857180f5b2319317d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f77f5e5ed1f320caa44a868a7cbedd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a31f77f5e5ed1f320caa44a868a7cbedd">startDQThread</a> (void *data)</td></tr>
<tr class="memdesc:a31f77f5e5ed1f320caa44a868a7cbedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts DQ Thread.  <a href="#a31f77f5e5ed1f320caa44a868a7cbedd">More...</a><br /></td></tr>
<tr class="separator:a31f77f5e5ed1f320caa44a868a7cbedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa798d14493de321fa90aeab6d944ca87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#aa798d14493de321fa90aeab6d944ca87">stopDQThread</a> ()</td></tr>
<tr class="memdesc:aa798d14493de321fa90aeab6d944ca87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force stops the DQ Thread if it is running.  <a href="#aa798d14493de321fa90aeab6d944ca87">More...</a><br /></td></tr>
<tr class="separator:aa798d14493de321fa90aeab6d944ca87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d139a8bfe728c6ad05d760d55c588b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a86d139a8bfe728c6ad05d760d55c588b">waitForDQThread</a> (uint32_t max_wait_ms)</td></tr>
<tr class="memdesc:a86d139a8bfe728c6ad05d760d55c588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the DQ Thread to stop.  <a href="#a86d139a8bfe728c6ad05d760d55c588b">More...</a><br /></td></tr>
<tr class="separator:a86d139a8bfe728c6ad05d760d55c588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a241f552ce68715743739e00992960784"><td class="memItemLeft" align="right" valign="top">pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a241f552ce68715743739e00992960784">plane_lock</a></td></tr>
<tr class="memdesc:a241f552ce68715743739e00992960784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex lock used along with <a class="el" href="classNvV4l2ElementPlane.html#acf2106b256d968890443f75d60e1e0eb" title="Plane condition that application can wait on to receive notifications from qBuffer/dqBuffer. ">plane_cond</a>.  <a href="#a241f552ce68715743739e00992960784">More...</a><br /></td></tr>
<tr class="separator:a241f552ce68715743739e00992960784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2106b256d968890443f75d60e1e0eb"><td class="memItemLeft" align="right" valign="top">pthread_cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#acf2106b256d968890443f75d60e1e0eb">plane_cond</a></td></tr>
<tr class="memdesc:acf2106b256d968890443f75d60e1e0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plane condition that application can wait on to receive notifications from <a class="el" href="classNvV4l2ElementPlane.html#a70bc2789a1af8358759c0f7f205da5ce" title="Queues a buffer on the plane. ">qBuffer</a>/<a class="el" href="classNvV4l2ElementPlane.html#ad3f34a09328c4dadbd1b20efa9cf4c53" title="Dequeues a buffer from the plane. ">dqBuffer</a>.  <a href="#acf2106b256d968890443f75d60e1e0eb">More...</a><br /></td></tr>
<tr class="separator:acf2106b256d968890443f75d60e1e0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a72623758a574376417ea6e6b16183e30"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNvV4l2ElementPlane.html#a72623758a574376417ea6e6b16183e30">NvV4l2Element</a></td></tr>
<tr class="separator:a72623758a574376417ea6e6b16183e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1f7c50ec5d7c90fd235566556f5bcf97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* NvV4l2ElementPlane::dqThreadCallback)(struct v4l2_buffer *v4l2_buf, <a class="el" href="classNvBuffer.html">NvBuffer</a> *buffer, <a class="el" href="classNvBuffer.html">NvBuffer</a> *shared_buffer, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a callback function type method that is called by the DQ Thread when it successfully dequeues a buffer from the plane. </p>
<p>Applications must implement this and set the callback using <a class="el" href="classNvV4l2ElementPlane.html#a37f213325e0e4857180f5b2319317d6a" title="Sets the DQ Thread callback method. ">setDQThreadCallback</a>.</p>
<p>Setting the stream to off automatically stops this thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#a37f213325e0e4857180f5b2319317d6a" title="Sets the DQ Thread callback method. ">setDQThreadCallback</a>, <a class="el" href="classNvV4l2ElementPlane.html#a31f77f5e5ed1f320caa44a868a7cbedd" title="Starts DQ Thread. ">startDQThread</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v4l2_buf</td><td>A pointer to the <code>v4l2_buffer</code> structure that is used for dequeueing. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> object at the <code>index</code> contained in <code>v4l2_buf</code>. </td></tr>
    <tr><td class="paramname">shared_buffer</td><td>A pointer to the <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> object if the plane shares a buffer with other elements, else NULL. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to application specific data that is set with <a class="el" href="classNvV4l2ElementPlane.html#a31f77f5e5ed1f320caa44a868a7cbedd" title="Starts DQ Thread. ">startDQThread</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the application implementing this call returns FALSE, the DQThread is stopped; else, the DQ Thread continues running. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00422">422</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af89cfe87d8f818beb0478bcf5b72574c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NvV4l2ElementPlane::deinitPlane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that encapsulates all the method calls required to deinitialize the plane for streaming. </p>
<p>For each of the buffers, unmaps/deallocates memory depending on the memory type. Then, calls reqbuf with count zero.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#a89959f455e5222f686187cc826b1b345" title="Helper method that encapsulates all the method calls required to set up the plane for streaming...">setupPlane</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3f34a09328c4dadbd1b20efa9cf4c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::dqBuffer </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_buffer &amp;&#160;</td>
          <td class="paramname"><em>v4l2_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNvBuffer.html">NvBuffer</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNvBuffer.html">NvBuffer</a> **&#160;</td>
          <td class="paramname"><em>shared_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_retries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeues a buffer from the plane. </p>
<p>This is a blocking call. This call returns when a buffer is successfully dequeued or timeout is reached. If <em>buffer</em> is not NULL, returns the <code><a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a></code> object at the index returned by the <code>VIDIOC_DQBUF</code> IOCTL. If this plane shares a buffer with other elements and <em>shared_buffer</em> is not NULL, returns the shared <code>NvBuffer</code> object in <em>shared_buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v4l2_buf</td><td>A reference to the <code>v4l2_buffer</code> structure to use for dequeueing. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Returns a pointer to a pointer to the <code>NvBuffer</code> object associated with the dequeued buffer. Can be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shared_buffer</td><td>Returns a pointer to a pointer to the shared <code>NvBuffer</code> object if the queued buffer is shared with other elements. Can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_retries</td><td>Number of times to try dequeuing a buffer before a failure is returned. In case of non-blocking mode, this is equivalent to the number of milliseconds to try to dequeue a buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a81120b7a996c523956227c221f2214df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::exportBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the buffer as DMABUF FD. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method works only for <code>V4L2_MEMORY_MMAP</code> memory.</dd></dl>
<p>Calls <code>VIDIOC_EXPBUF</code> IOCTL internally. Populates the <em>fd</em> member of all the <code><a class="el" href="structNvBuffer_1_1NvBufferPlane.html" title="Holds the buffer plane parameters. ">NvBuffer::NvBufferPlane</a></code> members of <code><a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a></code> object at index <em>buf_in</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_index</td><td>Specifies the index of the buffer to export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afcb80de93e057abb40702668913b7ac0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum v4l2_buf_type NvV4l2ElementPlane::getBufType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the streaming/buffer type of this plane. </p>
<dl class="section return"><dt>Returns</dt><dd>Type of the buffer belonging to enum <code>v4l2_buf_type</code>. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00269">269</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90873cb46d5b5f7cb944e3c2dee0ad40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::getCrop </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_crop &amp;&#160;</td>
          <td class="paramname"><em>crop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the cropping rectangle for the plane. </p>
<p>Calls <b>VIDIOC_G_CROP</b> <code>IOCTL</code> internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crop</td><td>A reference to the <code>v4l2_crop</code> structure to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a92938f266cb5c2dd9a9de68af240c835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::getFormat </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_format &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the plane format. </p>
<p>Calls <b>VIDIOC_G_FMT</b> <code>IOCTL</code> internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">format</td><td>A reference to the <code>v4l2_format</code> structure to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a868d438908f3d267dd4af1033133892f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNvBuffer.html">NvBuffer</a>* NvV4l2ElementPlane::getNthBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a></code> object at index n. </p>
<dl class="section return"><dt>Returns</dt><dd><code>NvBuffer</code> object at index n, NULL if n &gt;= number of buffers. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5cd394a7e0a4afd69395759aeac8787"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvV4l2ElementPlane::getNumBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of buffers allocated/requested on the plane. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of buffers. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00321">321</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac34236cdee2e7c3e34dda0f227584832"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvV4l2ElementPlane::getNumPlanes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of planes buffers on this plane for the currently set format. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of planes. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00332">332</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe813f1ac780689ea75207866fe12478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvV4l2ElementPlane::getNumQueuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of buffers currently queued on the plane. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of buffers currently queued on the plane. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00358">358</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac6e57acbf072d72cc425a33ad3b3b7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvV4l2ElementPlane::getStreamStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the plane is streaming. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the plane is streaming, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a476f17aad888988e08be0a6beb7eadc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvV4l2ElementPlane::getTotalDequeuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total number of buffers dequeued from the plane. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of buffers dequeued from the plane. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00368">368</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f89b524a97ebf05fb93a72f4e027118"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvV4l2ElementPlane::getTotalQueuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total number of buffers queued on the plane. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of buffers queued on the plane. </dd></dl>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00378">378</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="a712f71901a43d1e47881bdc7d22a708b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::mapOutputBuffers </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_buffer &amp;&#160;</td>
          <td class="paramname"><em>v4l2_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dmabuff_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the NvMMBuffer to <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> for V4L2_MEMORY_DMABUF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v4l2_buf</td><td>Address of the <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> to which the NvMMBuffer is mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmabuff_fd</td><td>Index to the field that holds NvMMBuffer attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a70bc2789a1af8358759c0f7f205da5ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::qBuffer </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_buffer &amp;&#160;</td>
          <td class="paramname"><em>v4l2_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNvBuffer.html">NvBuffer</a> *&#160;</td>
          <td class="paramname"><em>shared_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a buffer on the plane. </p>
<p>This method calls <code>VIDIOC_QBUF</code> internally. If this plane is sharing a buffer with other elements, the application can pass the pointer to the shared <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> object in <em>shared_buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v4l2_buf</td><td>A reference to the <code>v4l2_buffer</code> structure to use for queueing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shared_buffer</td><td>A pointer to the shared <code>NvBuffer</code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a17d8bfdcbf298d7671e5d7bf73dbb219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::queryBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the status of the buffer at the index. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method works only for <code>V4L2_MEMORY_MMAP</code> memory.</dd></dl>
<p>Calls <code>VIDIOC_QUERYBUF</code> IOCTL internally. Populates the <em>length</em> and <em>mem_offset</em> members of all the <a class="el" href="structNvBuffer_1_1NvBufferPlane.html" title="Holds the buffer plane parameters. ">NvBuffer::NvBufferPlane</a> members of the <code>NvBuffer</code> object at index <em>buf_index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_index</td><td>Specifies the index of the buffer to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a88154394fcedad772985741d3d2bfbb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::reqbufs </td>
          <td>(</td>
          <td class="paramtype">enum v4l2_memory&#160;</td>
          <td class="paramname"><em>mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests for buffers on the plane. </p>
<p>Calls <code>VIDIOC_REQBUFS</code> IOCTL internally. Creates an array of <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> of length equal to the count returned by the IOCTL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_type</td><td>Specifies the type of V4L2 memory to be requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Specifies the number of buffers to request on the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adf49ef49e3f33de468ba210dd66caa4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NvV4l2ElementPlane::setBufferPlaneFormat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNvBuffer_1_1NvBufferPlaneFormat.html">NvBuffer::NvBufferPlaneFormat</a> *&#160;</td>
          <td class="paramname"><em>planefmts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the format of the planes of the buffer that is used with this plane. </p>
<p>The buffer plane format must be set before calling reqbuf since these are needed by the <a class="el" href="classNvBuffer.html" title="Class representing a buffer. ">NvBuffer</a> constructor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#a88154394fcedad772985741d3d2bfbb2" title="Requests for buffers on the plane. ">reqbufs</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_planes</td><td>Number of planes in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planefmts</td><td>A pointer to the array of <code>NvBufferPlaneFormat</code> that describes the format of each of the plane. The array length must be at least <em>n_planes</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37f213325e0e4857180f5b2319317d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvV4l2ElementPlane::setDQThreadCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNvV4l2ElementPlane.html#a1f7c50ec5d7c90fd235566556f5bcf97">dqThreadCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the DQ Thread callback method. </p>
<p>The callback method is called from the DQ Thread once a buffer is successfully dequeued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Method to be called upon succesful dequeue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE for success, FALSE for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aec63b4567369162dd28b8160401ade30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::setFormat </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_format &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the plane format. </p>
<p>Calls <b>VIDIOC_S_FMT</b> <code>IOCTL</code> internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>A reference to the <code>v4l2_format</code> structure to be set on the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a01797837e4ba47f4737b5846becb182b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::setSelection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct v4l2_rect &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the selection rectangle for the plane. </p>
<p>Calls <b>VIDIOC_S_SELECTION</b> IOCTL internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Specifies the rectangle selection type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the flags to control selection adjustments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>A reference to the selection rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eec8bb8904bb33d995814f02045029c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::setStreamParms </td>
          <td>(</td>
          <td class="paramtype">struct v4l2_streamparm &amp;&#160;</td>
          <td class="paramname"><em>parm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets streaming parameters. </p>
<p>Calls <code>VIDIOC_S_PARM</code> IOCTL internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parm</td><td>A reference to the <code>v4l2_streamparm</code> structure to be set on the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a03164dde4d7ab41f3e92b41e13059316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::setStreamStatus </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts or stops streaming on the plane. </p>
<p>Calls <code>VIDIOC_STREAMON/VIDIOC_STREAMOFF</code> IOCTLs internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Must be TRUE to start the stream, FALSE to stop the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a89959f455e5222f686187cc826b1b345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::setupPlane </td>
          <td>(</td>
          <td class="paramtype">enum v4l2_memory&#160;</td>
          <td class="paramname"><em>mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that encapsulates all the method calls required to set up the plane for streaming. </p>
<p>Calls reqbuf internally. Then, for each of the buffers, calls <a class="el" href="classNvV4l2ElementPlane.html#a17d8bfdcbf298d7671e5d7bf73dbb219" title="Queries the status of the buffer at the index. ">queryBuffer</a>, <a class="el" href="classNvV4l2ElementPlane.html#a81120b7a996c523956227c221f2214df" title="Exports the buffer as DMABUF FD. ">exportBuffer</a> and maps the buffer/allocates the buffer memory depending on the memory type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#af89cfe87d8f818beb0478bcf5b72574c" title="Helper method that encapsulates all the method calls required to deinitialize the plane for streaming...">deinitPlane</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_type</td><td>V4L2 Memory to use on the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buffers</td><td>Number of buffer to request on the plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>boolean value indicating if the buffers should be mapped to memory (Only for V4L2_MEMORY_MMAP). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>boolean valued indicating whether the buffers should be allocated memory (Only for V4L2_MEMORY_USERPTR). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a31f77f5e5ed1f320caa44a868a7cbedd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::startDQThread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts DQ Thread. </p>
<p>This method starts a thread internally. On successful dequeue of a buffer from the plane, the <a class="el" href="classNvV4l2ElementPlane.html#a1f7c50ec5d7c90fd235566556f5bcf97" title="This is a callback function type method that is called by the DQ Thread when it successfully dequeues...">dqThreadCallback</a> method set using <a class="el" href="classNvV4l2ElementPlane.html#a37f213325e0e4857180f5b2319317d6a" title="Sets the DQ Thread callback method. ">setDQThreadCallback</a> is called.</p>
<p>Setting the stream to off automatically stops the thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#aa798d14493de321fa90aeab6d944ca87" title="Force stops the DQ Thread if it is running. ">stopDQThread</a>, <a class="el" href="classNvV4l2ElementPlane.html#a86d139a8bfe728c6ad05d760d55c588b" title="Waits for the DQ Thread to stop. ">waitForDQThread</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the application data. This is provided as an argument in the <code>dqThreadCallback</code> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa798d14493de321fa90aeab6d944ca87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::stopDQThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force stops the DQ Thread if it is running. </p>
<p>Does not work when the device is opened in blocking mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#a31f77f5e5ed1f320caa44a868a7cbedd" title="Starts DQ Thread. ">startDQThread</a>, <a class="el" href="classNvV4l2ElementPlane.html#a86d139a8bfe728c6ad05d760d55c588b" title="Waits for the DQ Thread to stop. ">waitForDQThread</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aed393217479ba28832083efc2a67e733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::unmapOutputBuffers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dmabuff_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmaps the NvMMBuffer for V4L2_MEMORY_DMABUF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>for the current buffer index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmabuff_fd</td><td>Index to the field that holds NvMMBuffer attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aac48042ca22a79d45600714ab75671f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::waitAllBuffersDequeued </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_wait_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until all buffers of the plane are dequeued. </p>
<p>This is a blocking call that returns when all the buffers are dequeued or timeout is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_wait_ms</td><td>Maximum time to wait, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c2222d5ca151087f02ea7d26a8bbfb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::waitAllBuffersQueued </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_wait_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until all buffers of the plane are queued. </p>
<p>This is a blocking call that returns when all the buffers are queued or timeout is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_wait_ms</td><td>Maximum time to wait, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a86d139a8bfe728c6ad05d760d55c588b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NvV4l2ElementPlane::waitForDQThread </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_wait_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the DQ Thread to stop. </p>
<p>This method waits until the DQ Thread stops or timeout is reached.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNvV4l2ElementPlane.html#a31f77f5e5ed1f320caa44a868a7cbedd" title="Starts DQ Thread. ">startDQThread</a>, <a class="el" href="classNvV4l2ElementPlane.html#aa798d14493de321fa90aeab6d944ca87" title="Force stops the DQ Thread if it is running. ">stopDQThread</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_wait_ms</td><td>Maximum wait time, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a72623758a574376417ea6e6b16183e30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classNvV4l2Element.html">NvV4l2Element</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00583">583</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="acf2106b256d968890443f75d60e1e0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_cond_t NvV4l2ElementPlane::plane_cond</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plane condition that application can wait on to receive notifications from <a class="el" href="classNvV4l2ElementPlane.html#a70bc2789a1af8358759c0f7f205da5ce" title="Queues a buffer on the plane. ">qBuffer</a>/<a class="el" href="classNvV4l2ElementPlane.html#ad3f34a09328c4dadbd1b20efa9cf4c53" title="Dequeues a buffer from the plane. ">dqBuffer</a>. </p>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00475">475</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<a class="anchor" id="a241f552ce68715743739e00992960784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t NvV4l2ElementPlane::plane_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex lock used along with <a class="el" href="classNvV4l2ElementPlane.html#acf2106b256d968890443f75d60e1e0eb" title="Plane condition that application can wait on to receive notifications from qBuffer/dqBuffer. ">plane_cond</a>. </p>

<p>Definition at line <a class="el" href="NvV4l2ElementPlane_8h_source.html#l00474">474</a> of file <a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>multimedia_api/ll_samples/include/<a class="el" href="NvV4l2ElementPlane_8h_source.html">NvV4l2ElementPlane.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">
        Advance Information | Subject to Change |
        Generated by NVIDIA | Thu Jul 2 2020 14:15:49 |
        PR-08664-R32
      </li>
     </ul>
  </div>
<script type="text/javascript">if (_satellite) _satellite.pageBottom();</script>
</body>
</html>
