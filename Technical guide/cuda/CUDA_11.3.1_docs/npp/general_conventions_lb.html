<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NVIDIA 2D Image And Signal Performance Primitives (NPP): General API Conventions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVIDIA 2D Image And Signal Performance Primitives (NPP)
   &#160;<span id="projectnumber">Version 11.3.0.*</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">General API Conventions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="memory_management_lb"></a>
Memory Management</h1>
<p>The design of all the NPP functions follows the same guidelines as other NVIDIA CUDA libraries like cuFFT and cuBLAS. That is that all pointer arguments in those APIs are device pointers.</p>
<p>This convention enables the individual developer to make smart choices about memory management that minimize the number of memory transfers. It also allows the user the maximum flexibility regarding which of the various memory transfer mechanisms offered by the CUDA runtime is used, e.g. synchronous or asynchronous memory transfers, zero-copy and pinned memory, etc.</p>
<p>The most basic steps involved in using NPP for processing data is as follows:</p>
<ol type="1">
<li>Transfer input data from the host to device using<div class="fragment"><div class="line">cudaMemCpy(...)</div>
</div><!-- fragment --></li>
<li>Process data using one or several NPP functions or custom CUDA kernels</li>
<li>Transfer the result data from the device to the host using<div class="fragment"><div class="line">cudaMemCpy(...)</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="general_scratch_buffer"></a>
Scratch Buffer and Host Pointer</h2>
<p>Some primitives of NPP require additional device memory buffers (scratch buffers) for calculations, e.g. signal and image reductions (Sum, Max, Min, MinMax, etc.). In order to give the NPP user maximum control regarding memory allocations and performance, it is the user's responsibility to allocate and delete those temporary buffers. For one this has the benefit that the library will not allocate memory unbeknownst to the user. It also allows developers who invoke the same primitive repeatedly to allocate the scratch only once, improving performance and potential device-memory fragmentation.</p>
<p>Scratch-buffer memory is unstructured and may be passed to the primitive in uninitialized form. This allows for reuse of the same scratch buffers with any primitive require scratch memory, as long as it is sufficiently sized.</p>
<p>The minimum scratch-buffer size for a given primitive (e.g. <a class="el" href="group__signal__sum.html#ga56c286b3174c578630ce532263018626">nppsSum_32f()</a>) can be obtained by a companion function (e.g. <a class="el" href="group__signal__sum.html#ga5ab127775ea80ad9151cc8d05cb3ecc1">nppsSumGetBufferSize_32f()</a>). The buffer size is returned via a host pointer as allocation of the scratch-buffer is performed via CUDA runtime host code.</p>
<p>An example to invoke signal sum primitive and allocate and free the necessary scratch memory: </p>
<div class="fragment"><div class="line">* <span class="comment">// pSrc, pSum, pDeviceBuffer are all device pointers. </span></div>
<div class="line">* <a class="code" href="group__npp__basic__types.html#ga274ed0e3c4cbc89f644143f64e2391ee">Npp32f</a> * pSrc; </div>
<div class="line">* <a class="code" href="group__npp__basic__types.html#ga274ed0e3c4cbc89f644143f64e2391ee">Npp32f</a> * pSum; </div>
<div class="line">* <a class="code" href="group__npp__basic__types.html#ga29b502b6816fc0066fd59538483a5b62">Npp8u</a> * pDeviceBuffer;</div>
<div class="line">* <span class="keywordtype">int</span> nLength = 1024;</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Allocate the device memroy.</span></div>
<div class="line">* cudaMalloc((<span class="keywordtype">void</span> **)(&amp;pSrc), <span class="keyword">sizeof</span>(<a class="code" href="group__npp__basic__types.html#ga274ed0e3c4cbc89f644143f64e2391ee">Npp32f</a>) * nLength);</div>
<div class="line">* <a class="code" href="group__signal__set.html#ga7f6a6c1841f60d48e32dbbe42fbaf8bf">nppsSet_32f</a>(1.0f, pSrc, nLength);  </div>
<div class="line">* cudaMalloc((<span class="keywordtype">void</span> **)(&amp;pSum), <span class="keyword">sizeof</span>(<a class="code" href="group__npp__basic__types.html#ga274ed0e3c4cbc89f644143f64e2391ee">Npp32f</a>) * 1);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Compute the appropriate size of the scratch-memory buffer </span></div>
<div class="line">* <span class="keywordtype">int</span> nBufferSize;</div>
<div class="line">* <a class="code" href="group__signal__sum.html#ga5ab127775ea80ad9151cc8d05cb3ecc1">nppsSumGetBufferSize_32f</a>(nLength, &amp;nBufferSize);</div>
<div class="line">* <span class="comment">// Allocate the scratch buffer </span></div>
<div class="line">* cudaMalloc((<span class="keywordtype">void</span> **)(&amp;pDeviceBuffer), nBufferSize);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Call the primitive with the scratch buffer</span></div>
<div class="line">* <a class="code" href="group__signal__sum.html#ga56c286b3174c578630ce532263018626">nppsSum_32f</a>(pSrc, nLength, pSum, pDeviceBuffer);</div>
<div class="line">* <a class="code" href="group__npp__basic__types.html#ga274ed0e3c4cbc89f644143f64e2391ee">Npp32f</a> nSumHost;</div>
<div class="line">* cudaMemcpy(&amp;nSumHost, pSum, <span class="keyword">sizeof</span>(<a class="code" href="group__npp__basic__types.html#ga274ed0e3c4cbc89f644143f64e2391ee">Npp32f</a>) * 1, cudaMemcpyDeviceToHost);</div>
<div class="line">* printf(<span class="stringliteral">&quot;sum = %f\n&quot;</span>, nSumHost); <span class="comment">// nSumHost = 1024.0f;</span></div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Free the device memory</span></div>
<div class="line">* cudaFree(pSrc);</div>
<div class="line">* cudaFree(pDeviceBuffer);</div>
<div class="line">* cudaFree(pSum);</div>
<div class="line">* </div>
</div><!-- fragment --><h1><a class="anchor" id="npp_naming"></a>
Function Naming</h1>
<p>Since NPP is a C API and therefore does not allow for function overloading for different data-types the NPP naming convention addresses the need to differentiate between different flavors of the same algorithm or primitive function but for various data types. This disambiguation of different flavors of a primitive is done via a suffix containing data type and other disambiguating information.</p>
<p>In addition to the flavor suffix, all NPP functions are prefixed with by the letters "npp". Primitives belonging to NPP's image-processing module add the letter "i" to the npp prefix, i.e. are prefixed by "nppi". Similarly signal-processing primitives are prefixed with "npps".</p>
<p>The general naming scheme is:</p>
<div class="fragment"><div class="line">npp&lt;module info&gt;&lt;PrimitiveName&gt;_&lt;data-type info&gt;[_&lt;additional flavor info&gt;](&lt;parameter list&gt;)</div>
</div><!-- fragment --><p>The data-type information uses the same names as the <a class="el" href="group__npp__basic__types.html">Basic NPP Data Types</a>. For example the data-type information "8u" would imply that the primitive operates on <a class="el" href="group__npp__basic__types.html#ga29b502b6816fc0066fd59538483a5b62" title="8-bit unsigned chars ">Npp8u</a> data.</p>
<p>If a primitive consumes different type data from what it produces, both types will be listed in the order of consumed to produced data type.</p>
<p>Details about the "additional flavor information" is provided for each of the NPP modules, since each problem domain uses different flavor information suffixes.</p>
<h1><a class="anchor" id="integer_result_scaling"></a>
Integer Result Scaling</h1>
<p>NPP signal processing and imaging primitives often operate on integer data. This integer data is usually a fixed point fractional representation of some physical magnitue (e.g. luminance). Because of this fixed-point nature of the representation many numerical operations (e.g. addition or multiplication) tend to produce results exceeding the original fixed-point range if treated as regular integers.</p>
<p>In cases where the results exceed the original range, these functions clamp the result values back to the valid range. E.g. the maximum positive value for a 16-bit unsigned integer is 32767. A multiplication operation of 4 * 10000 = 40000 would exceed this range. The result would be clamped to be 32767.</p>
<p>To avoid the level of lost information due to clamping most integer primitives allow for result scaling. Primitives with result scaling have the "Sfs" suffix in their name and provide a parameter "nScaleFactor" that controls the amount of scaling. Before the results of an operation are clamped to the valid output-data range by multiplying them with <img class="formulaInl" alt="$2^{\mbox{-nScaleFactor}}$" src="form_128.png"/>.</p>
<p>Example: The primitive <a class="el" href="group__signal__square.html#gad0197453d4d75d81bc96e654ed892fa8">nppsSqr_8u_Sfs()</a> computes the square of 8-bit unsigned sample values in a signal (1D array of values). The maximum value of a 8-bit value is 255. The square of <img class="formulaInl" alt="$255^2 = 65025$" src="form_129.png"/> which would be clamped to 255 if no result scaling is performed. In order to map the maximum value of 255 to 255 in the result, one would specify an integer result scaling factor of 8, i.e. multiply each result with <img class="formulaInl" alt="$2^{-8} = \frac{1}{2^8} = \frac{1}{256}$" src="form_130.png"/>. The final result for a signal value of 255 being squared and scaled would be: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[255^2\cdot 2^{-8} = 254.00390625\]" src="form_131.png"/>
</p>
<p> which would be rounded to a final result of 254.</p>
<p>A medium gray value of 128 would result in </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[128^2 * 2^{-8} = 64\]" src="form_132.png"/>
</p>
<h1><a class="anchor" id="rounding_modes"></a>
Rounding Modes</h1>
<p>Many NPP functions require converting floating-point values to integers. The <a class="el" href="group__typedefs__npp.html#ga120be98eca90f44701e361bec185f0af" title="Rounding Modes. ">NppRoundMode</a> enum lists NPP's supported rounding modes. Not all primitives in NPP that perform rounding as part of their functionality allow the user to specify the round-mode used. Instead they use NPP's default rounding mode, which is <a class="el" href="group__typedefs__npp.html#gga120be98eca90f44701e361bec185f0afa4221751d7621ebb6ece1b588adbce15b" title="Round according to financial rule. ">NPP_RND_FINANCIAL</a>.</p>
<h2><a class="anchor" id="rounding_mode_parameter"></a>
Rounding Mode Parameter</h2>
<p>A subset of NPP functions performing rounding as part of their functionality do allow the user to specify which rounding mode is used through a parameter of the <a class="el" href="group__typedefs__npp.html#ga120be98eca90f44701e361bec185f0af" title="Rounding Modes. ">NppRoundMode</a> type. </p>
</div></div><!-- contents -->
<HR>
<center>Copyright &copy; 2009-2020 NVIDIA Corporation</center>
<HR>